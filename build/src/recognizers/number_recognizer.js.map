{"version":3,"file":"number_recognizer.js","sourceRoot":"","sources":["../../../src/recognizers/number_recognizer.ts"],"names":[],"mappings":"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","sourcesContent":["import wordsToNumbers from 'words-to-numbers';\n\nimport {Recognizer, Token, UNKNOWN} from '../tokenizer';\nimport {PeekableSequence} from '../utilities';\n\nimport {QUANTITY} from './quantity_recognizer';\n\nexport class NumberRecognizer implements Recognizer {\n  lexicon: Set<string> = new Set([\n    'zero',     'one',      'two',      'three',   'four',    'five',\n    'six',      'seven',    'eight',    'nine',    'ten',     'eleven',\n    'twelve',   'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen',\n    'eighteen', 'nineteen', 'twenty',   'thirty',  'forty',   'fifty',\n    'sixty',    'seventy',  'eighty',   'ninety',  'hundred', 'thousand',\n    'million',  'trillion'\n  ]);\n\n  private parseNumberSequence(sequence: PeekableSequence<string>): Token {\n    const terms: string[] = [];\n    while (!sequence.atEOF()) {\n      if (this.lexicon.has(sequence.peek())) {\n        terms.push(sequence.get());\n      } else {\n        break;\n      }\n    }\n\n    if (terms.length === 0) {\n      throw TypeError('parseNumberSequence: expected a number.');\n    }\n\n    const text = terms.join(' ');\n    const value = wordsToNumbers(text);\n    if (typeof (value) !== 'number') {\n      // TODO: consider logging an error and then returning the unknown token.\n      throw TypeError('parseNumberSequence: expected a number.');\n    }\n    return {type: QUANTITY, text, value} as Token;\n  }\n\n  private parseTextSequence(sequence: PeekableSequence<string>): Token {\n    const terms: string[] = [];\n    while (!sequence.atEOF()) {\n      if (!this.lexicon.has(sequence.peek())) {\n        terms.push(sequence.get());\n      } else {\n        break;\n      }\n    }\n\n    if (terms.length === 0) {\n      throw TypeError('parseTextSequence: expected a word.');\n    }\n\n    const text = terms.join(' ');\n    return {type: UNKNOWN, text};\n  }\n\n  private parseSequence(sequence: PeekableSequence<string>): Token[] {\n    const tokens: Token[] = [];\n    while (!sequence.atEOF()) {\n      if (this.lexicon.has(sequence.peek())) {\n        tokens.push(this.parseNumberSequence(sequence));\n      } else {\n        tokens.push(this.parseTextSequence(sequence));\n      }\n    }\n    return tokens;\n  }\n\n  apply =\n      (token: Token) => {\n        const text = token.text;\n        const terms = text.split(' ');\n        return this.parseSequence(\n            new PeekableSequence(terms[Symbol.iterator]()));\n      }\n\n  terms =\n      () => {\n        return this.lexicon;\n      }\n\n  stemmer = (word: string): string => {\n    // DESIGN NOTE: NumberRecognizer does not stem.\n    return word;\n  }\n}\n"]}