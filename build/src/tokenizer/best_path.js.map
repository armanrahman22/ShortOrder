{"version":3,"file":"best_path.js","sourceRoot":"","sources":["../../../src/tokenizer/best_path.ts"],"names":[],"mappings":";;AAMA,MAAM,MAAM;IAMV,YAAY,KAAa,EAAE,KAAa;QAJxC,UAAK,GAAG,CAAC,QAAQ,CAAC;QAClB,oBAAe,GAAgB,IAAI,CAAC;QACpC,kBAAa,GAAc,IAAI,CAAC;QAG9B,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACrB,CAAC;CACF;AAED,MAAM,KAAK;IAGT,YAAY,SAAmB;QAC7B,MAAM,WAAW,GAAG,SAAS,CAAC,MAAM,CAAC;QAErC,0DAA0D;QAC1D,MAAM,WAAW,GAAG,EAAC,KAAK,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,EAAC,CAAC;QACrD,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE;YAC7C,MAAM,KAAK,GAAG,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;YAC1C,OAAO,IAAI,MAAM,CAAC,CAAC,WAAW,EAAE,GAAG,KAAK,CAAC,EAAE,KAAK,CAAC,CAAC;QACpD,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC,EAAE,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;QAE9C,oDAAoD;QACpD,mDAAmD;QACnD,8CAA8C;QAC9C,uCAAuC;QACvC,gDAAgD;QAChD,4CAA4C;QAC5C,QAAQ;QACR,aAAa;QACb,kEAAkE;QAClE,8DAA8D;QAC9D,QAAQ;QACR,MAAM;IACR,CAAC;IAED,QAAQ;QACN,yBAAyB;QACzB,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;YACtC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;gBAC5B,MAAM,WAAW,GAAG,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;gBACxC,IAAI,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;oBACtC,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;oBAC1C,MAAM,QAAQ,GAAG,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;oBAC3C,IAAI,MAAM,CAAC,KAAK,GAAG,QAAQ,EAAE;wBAC3B,MAAM,CAAC,KAAK,GAAG,QAAQ,CAAC;wBACxB,MAAM,CAAC,eAAe,GAAG,MAAM,CAAC;wBAChC,MAAM,CAAC,aAAa,GAAG,IAAI,CAAC;qBAC7B;iBACF;YACH,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,sDAAsD;QACtD,MAAM,WAAW,GAAG,EAAE,CAAC;QACvB,IAAI,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACtD,OAAO,OAAO,CAAC,eAAe,EAAE;YAC9B,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,aAAqB,CAAC,CAAC;YAChD,OAAO,GAAG,OAAO,CAAC,eAAe,CAAC;SACnC;QAED,MAAM,WAAW,GAAG,WAAW,CAAC,OAAO,EAAE,CAAC;QAE1C,OAAO,WAAW,CAAC;IACrB,CAAC;CACF;AAED,SAAgB,YAAY,CAAC,SAAmB;IAC9C,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,SAAS,CAAC,CAAC;IACnC,OAAO,KAAK,CAAC,QAAQ,EAAE,CAAC;AAC1B,CAAC;AAHD,oCAGC","sourcesContent":["export interface Edge {\n  score: number;\n  length: number;\n  label: number;\n}\n\nclass Vertex {\n  edges: Edge[];\n  score = -Infinity;\n  backtraceVertex: Vertex|null = null;\n  backtraceEdge: Edge|null = null;\n\n  constructor(edges: Edge[], score: number) {\n    this.edges = edges;\n    this.score = score;\n  }\n}\n\nclass Graph {\n  vertices: Vertex[];\n\n  constructor(edgeLists: Edge[][]) {\n    const vertexCount = edgeLists.length;\n\n    // NOTE: using label value of -1 as sentinel for no label.\n    const defaultEdge = {score: 0, length: 1, label: -1};\n    this.vertices = edgeLists.map((edges, index) => {\n      const score = index === 0 ? 0 : -Infinity;\n      return new Vertex([defaultEdge, ...edges], score);\n    });\n    this.vertices.push(new Vertex([], -Infinity));\n\n    // this.vertices = edgeLists.map((edges, index) => {\n    //     const filteredEdges = edges.filter((edge) =>\n    //         index + edge.length < vertexCount);\n    //     if (index === vertexCount - 1) {\n    //         // No default edge from final vertex.\n    //         return new Vertex(filteredEdges);\n    //     }\n    //     else {\n    //         // Other vertices get default edge to following vertex.\n    //         return new Vertex([defaultEdge, ...filteredEdges]);\n    //     }\n    // });\n  }\n\n  findPath() {\n    // Forward propate paths.\n    this.vertices.forEach((vertex, index) => {\n      vertex.edges.forEach((edge) => {\n        const targetIndex = index + edge.length;\n        if (targetIndex < this.vertices.length) {\n          const target = this.vertices[targetIndex];\n          const newScore = vertex.score + edge.score;\n          if (target.score < newScore) {\n            target.score = newScore;\n            target.backtraceVertex = vertex;\n            target.backtraceEdge = edge;\n          }\n        }\n      });\n    });\n\n    // Extract path by walking backwards from last vertex.\n    const reversePath = [];\n    let current = this.vertices[this.vertices.length - 1];\n    while (current.backtraceVertex) {\n      reversePath.push(current.backtraceEdge as Edge);\n      current = current.backtraceVertex;\n    }\n\n    const forwardPath = reversePath.reverse();\n\n    return forwardPath;\n  }\n}\n\nexport function findBestPath(edgeLists: Edge[][]) {\n  const graph = new Graph(edgeLists);\n  return graph.findPath();\n}"]}