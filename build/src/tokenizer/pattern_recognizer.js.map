{"version":3,"file":"pattern_recognizer.js","sourceRoot":"","sources":["../../../src/tokenizer/pattern_recognizer.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from 'fs';\nimport * as yaml from 'js-yaml';\n\nimport {copyArray, copyScalar} from '../utilities';\n\nimport {generateAliases, PID, Recognizer, StemmerFunction, Token, TokenFactory, Tokenizer} from '.';\n\nexport interface Item {\n  pid: PID;\n  name: string;\n  aliases: string[];\n}\n\nexport class Index<T extends Item> {\n  items: {[pid: number]: Item} = {};\n\n  addItem = (item: T) => {\n    if (this.items[item.pid] === undefined) {\n      this.items[item.pid] = item;\n    } else {\n      throw TypeError(`Index.addItem: found duplicate pid in item ${item}`);\n    }\n  }\n}\n\n// tslint:disable-next-line:no-any\nfunction ItemFromYamlItem(item: any): Item {\n  return {\n    pid: copyScalar<number>(item, 'pid', 'number'),\n    name: copyScalar<string>(item, 'name', 'string'),\n    aliases: copyArray<string>(item, 'aliases', 'string'),\n  };\n}\n\nexport function indexYamlFilename(filename: string): Index<Item> {\n  // tslint:disable-next-line:no-any\n  const yamlRoot: any = yaml.safeLoad(fs.readFileSync(filename, 'utf8'));\n\n  if (typeof (yamlRoot) !== 'object') {\n    throw TypeError('Inent: expected a top-level object with items array.');\n  }\n\n  const yamlItems = yamlRoot['items'] as Item[];\n  if (yamlItems === undefined || !Array.isArray(yamlRoot.items)) {\n    throw TypeError('Intent: expected items array.');\n  }\n\n  const index = new Index();\n  yamlItems.forEach(item => {\n    index.addItem(ItemFromYamlItem(item));\n  });\n\n  return index;\n}\n\nexport class PatternRecognizer<T extends Item> implements Recognizer {\n  index: Index<T>;\n  tokenizer: Tokenizer;\n  tokenFactory: TokenFactory<Token>;\n  stemmer: (word: string) => string;\n\n  constructor(\n      index: Index<T>, tokenFactory: TokenFactory<Token>, badWords: Set<string>,\n      stemmer: StemmerFunction = Tokenizer.defaultStemTerm, debugMode = false) {\n    this.index = index;\n    this.tokenizer = new Tokenizer(badWords, stemmer, debugMode);\n    this.stemmer = this.tokenizer.stemTerm;\n    this.tokenFactory = tokenFactory;\n\n    // Ingest index.\n    let aliasCount = 0;\n    Object.entries(this.index.items).forEach(([pid, item]) => {\n      item.aliases.forEach(aliasPattern => {\n        // console.log(aliasPattern);\n        for (const alias of generateAliases(aliasPattern)) {\n          // console.log(`  ${alias}`);\n          this.tokenizer.addItem(item.pid, alias);\n          aliasCount++;\n        }\n      });\n    });\n\n    // TODO: print name of tokenizer here?\n    console.log(`${Object.keys(this.index.items).length} items contributed ${\n        aliasCount} aliases.`);\n    console.log();\n  }\n\n  apply =\n      (token: Token) => {\n        const path = this.tokenizer.processQuery(token.text);\n        const terms = token.text.split(' ');\n\n        return this.tokenizer.tokenizeMatches(terms, path, this.tokenFactory);\n      }\n\n  terms = () => {\n    const terms = new Set<string>();\n    Object.entries(this.index.items).forEach(([pid, item]) => {\n      item.aliases.forEach(alias => {\n        const words = alias.split(' ');\n        words.forEach(word => {\n          terms.add(word);\n        });\n      });\n    });\n    return terms;\n  }\n}"]}