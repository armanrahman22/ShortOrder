{"version":3,"file":"diff.test.js","sourceRoot":"","sources":["../../../test/tokenizer/diff.test.ts"],"names":[],"mappings":"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","sourcesContent":["import 'mocha';\n\nimport {assert} from 'chai';\n\nimport {diff, diffString} from '../../src/tokenizer/diff';\n\ndescribe('Diff', () => {\n  describe('#general', () => {\n    it('should correctly match the prefix to the query string.', () => {\n      const cases: Array<\n          [[string, string], [string, number, number, number, number]]> =\n          [\n            [\n              ['abcdef', 'ab'],\n              ['ab', 0, 0, 1, 2]\n            ],  // Prefix match at position 0\n            [\n              ['abcdef', 'bcd'],\n              ['bcd', 1, 1, 3, 3]\n            ],  // Prefix match at position 1\n            [\n              ['abcdef', 'cde'],\n              ['cde', 2, 2, 4, 3]\n            ],  // Prefix match at position 2\n            [\n              ['abcdef', 'f'],\n              ['f', 5, 5, 5, 1]\n            ],  // Match at end of sequence `a`\n            [['abcdef', 'ac'], ['ac', 1, 0, 2, 2]],  // Delete one from middle.\n            [['abcdef', 'ad'], ['ad', 2, 0, 3, 2]],  // Delete two from middle.\n            [['abcdef', 'adf'], ['adf', 3, 0, 5, 3]],  // Delete in two places.\n            [\n              ['a', 'af'],\n              ['a', 1, 0, 0, 1]\n            ],  // BUG: Sequence `b` longer than `a`.\n            [\n              ['a', 'def'],\n              ['a', 3, 0, 0, 0]\n            ],  // BUG: Sequence `b` longer than `a`.\n            [['abc', 'adc'], ['abc', 1, 0, 2, 2]]  // Replace\n          ];\n\n      cases.forEach((item, index) => {\n        const query = item[0][0];\n        const prefix = item[0][1];\n\n        const expectedMatch = item[1][0];\n        const expectedCost = item[1][1];\n        const expectedLeftmostA = item[1][2];\n        const expectedRightmostA = item[1][3];\n        const expectedCommon = item[1][4];\n\n        const {match, cost, leftmostA, rightmostA, common} =\n            diffString(query, prefix);\n\n        console.log(\n            `\"${query}\" x \"${prefix}\" => \"${match}\", cost=${cost}, leftmost=${\n                leftmostA}, rightmost=${rightmostA}, common=${common}`);\n\n        assert.equal(match, expectedMatch);\n        assert.equal(cost, expectedCost);\n        assert.equal(leftmostA, expectedLeftmostA);\n        assert.equal(rightmostA, expectedRightmostA);\n        assert.equal(common, expectedCommon);\n      });\n    });\n  });\n\n  describe('#predicate', () => {\n    it('should work with an equality predicate.', () => {\n      const query = [1, 2, 3, 4, 5];\n      const prefix = [1, -1, 3];\n\n      // const predicate = (x:number, y:number) => {\n      function predicate(x: number, y: number) {\n        if (y < 0) {\n          return true;\n        } else {\n          return x === y;\n        }\n      }\n\n      const expectedMatch = [1, 2, 3];\n      const expectedCost = 0;\n\n      const {match, cost, rightmostA} = diff<number>(query, prefix, predicate);\n\n      assert.deepEqual(match, expectedMatch);\n      assert.equal(cost, expectedCost);\n    });\n  });\n\n  describe('#trailing junk', () => {\n    it('should not produce a match with trailing junk.', () => {\n      const query = [1, 2, 3, 4, 5];\n      const prefix = [1, 6];\n\n      const expectedMatch = [1, 2];\n      const expectedCost = 1;\n\n      const {match, cost, rightmostA} = diff<number>(query, prefix);\n\n      assert.deepEqual(match, expectedMatch);\n      assert.equal(cost, expectedCost);\n    });\n  });\n});\n"]}